from _typeshed import Incomplete
from collections.abc import Mapping, Callable
from os import PathLike
from typing import Any, Dict, Generator, List, Optional, Tuple, Type, Union, Literal

class Box(dict):
    def __new__(
        cls,
        *args: Any,
        default_box: bool = ...,
        default_box_attr: Any = ...,
        default_box_none_transform: bool = ...,
        default_box_create_on_get: bool = ...,
        frozen_box: bool = ...,
        camel_killer_box: bool = ...,
        conversion_box: bool = ...,
        modify_tuples_box: bool = ...,
        box_safe_prefix: str = ...,
        box_duplicates: str = ...,
        box_intact_types: Union[Tuple, List] = ...,
        box_recast: Optional[Dict] = ...,
        box_dots: bool = ...,
        box_class: Optional[Union[Dict, Type["Box"]]] = ...,
        box_namespace: Union[Tuple[str, ...], Literal[False]] = ...,
        on_change: Optional[Callable] = ...,
        **kwargs: Any,
    ): ...
    def __init__(
        self,
        *args: Any,
        default_box: bool = ...,
        default_box_attr: Any = ...,
        default_box_none_transform: bool = ...,
        default_box_create_on_get: bool = ...,
        frozen_box: bool = ...,
        camel_killer_box: bool = ...,
        conversion_box: bool = ...,
        modify_tuples_box: bool = ...,
        box_safe_prefix: str = ...,
        box_duplicates: str = ...,
        box_intact_types: Union[Tuple, List] = ...,
        box_recast: Optional[Dict] = ...,
        box_dots: bool = ...,
        box_class: Optional[Union[Dict, Type["Box"]]] = ...,
        box_namespace: Union[Tuple[str, ...], Literal[False]] = ...,
        on_change: Optional[Callable] = ...,
        **kwargs: Any,
    ) -> None: ...
    def __add__(self, other: Mapping[Any, Any]): ...
    def __radd__(self, other: Mapping[Any, Any]): ...
    def __iadd__(self, other: Mapping[Any, Any]): ...
    def __or__(self, other: Mapping[Any, Any]): ...
    def __ror__(self, other: Mapping[Any, Any]): ...
    def __ior__(self, other: Mapping[Any, Any]): ...  # type: ignore[override]
    def __sub__(self, other: Mapping[Any, Any]): ...
    def __hash__(self): ...
    def __dir__(self) -> List[str]: ...
    def __contains__(self, item) -> bool: ...
    def keys(self, dotted: Union[bool] = ...): ...
    def items(self, dotted: Union[bool] = ...): ...
    def get(self, key, default=...): ...
    def copy(self) -> Box: ...
    def __copy__(self) -> Box: ...
    def __deepcopy__(self, memodict: Incomplete | None = ...) -> Box: ...
    def __getitem__(self, item, _ignore_default: bool = ...): ...
    def __getattr__(self, item): ...
    def __setitem__(self, key, value): ...
    def __setattr__(self, key, value): ...
    def __delitem__(self, key): ...
    def __delattr__(self, item) -> None: ...
    def pop(self, key, *args): ...
    def clear(self) -> None: ...
    def popitem(self): ...
    def __iter__(self) -> Generator: ...
    def __reversed__(self) -> Generator: ...
    def to_dict(self) -> Dict: ...
    def update(self, *args, **kwargs) -> None: ...
    def merge_update(self, *args, **kwargs) -> None: ...
    def setdefault(self, item, default: Incomplete | None = ...): ...
    def _notify(self, key: Any, value: Any = ..., action: str = ..., is_root: bool = ...) -> None: ...
    def to_json(
        self, filename: Optional[Union[str, PathLike]] = ..., encoding: str = ..., errors: str = ..., **json_kwargs
    ): ...
    @classmethod
    def from_json(
        cls,
        json_string: Optional[str] = ...,
        filename: Optional[Union[str, PathLike]] = ...,
        encoding: str = ...,
        errors: str = ...,
        **kwargs,
    ) -> Box: ...
    def to_yaml(
        self,
        filename: Optional[Union[str, PathLike]] = ...,
        default_flow_style: bool = ...,
        encoding: str = ...,
        errors: str = ...,
        **yaml_kwargs,
    ): ...
    @classmethod
    def from_yaml(
        cls,
        yaml_string: Optional[str] = ...,
        filename: Optional[Union[str, PathLike]] = ...,
        encoding: str = ...,
        errors: str = ...,
        **kwargs,
    ) -> Box: ...
    def to_toml(self, filename: Optional[Union[str, PathLike]] = ..., encoding: str = ..., errors: str = ...): ...
    @classmethod
    def from_toml(
        cls,
        toml_string: Optional[str] = ...,
        filename: Optional[Union[str, PathLike]] = ...,
        encoding: str = ...,
        errors: str = ...,
        **kwargs,
    ) -> Box: ...
    def to_msgpack(self, filename: Optional[Union[str, PathLike]] = ..., **kwargs): ...
    @classmethod
    def from_msgpack(
        cls, msgpack_bytes: Optional[bytes] = ..., filename: Optional[Union[str, PathLike]] = ..., **kwargs
    ) -> Box: ...
